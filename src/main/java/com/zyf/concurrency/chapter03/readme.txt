3.对象的共享
    同步除了可用于实现原子性和 确定“临界区（Critical Section）”，还有一个重要方面：内存可见性

    3.1 可见性 NoVisibility
        在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。在缺乏足够同步的多线程程序中，要想对内存操作的执行顺序进行判断，几乎无法得出正确的结论。重排序问题
        只要有数据在多个线程之间共享，就使用正确的同步。

    3.1.1 失效数据 MutableInteger，SynchronizedInteger
        问题点：get和set是复合操作，使用内置锁真的可以锁住value中的值吗？
            如果一个线程调用get只是锁住了get，而set和get并不是同一个锁

    3.1.3
        加锁的含义不仅仅局限于互斥行为，海报包括内存可见性。为了确保所有线程都能看到共享变量的最新值
      所有执行读操作或者写操作的线程都必须在同一个锁上同步

    3.1.4 - CountingSheep
        volatile变量
            是Java提供的稍弱的同步机制，用于确保变量的更新操作通知到其他线程。
            volatile变量不会被该变量的操作与其他内存操作一起重排序，volatile变量不会被缓存在
            寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值
            局限性：
                加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能
                确保可见性 - 可参见代码CountingSheep

    3.2 发布与溢出 Secrets，UnsafeStates，ThisEscape，SafeListener
        只有当构造函数返回时，this引用才应该从主线程中逸出，构造函数可以将引用保存到某个地方，
     只要其他瑕疵不会在构造函数完成之前使用他。 - 可参见代码SafeListener

    3.3 线程封闭
        3.3.2 栈封闭 - Animals
        3.3.3 ThreadLocal类
            这个类能使线程中的某个值与保存值的对象关联起来，类中的方法为每个使用该变量的线程
         都存有一份独立的副本，因此get总是返回由当前执行线程在调用set时设置的最新值，当线程终止
         后，值会作为垃圾回收
         缺点：
            降低代码的可重用性，并在类之间引入隐含的耦合性

    3.4 不变性 - ThreeStooges
        不可变对象对象一定是线程安全的
        当满足一下条件时，对象才是不可变的
            1、对象创建以后，其状态就不能修改
            2、对象的所有域都是final类型
            3、对象是正确创建的（在对象创建期间，this引用没有溢出）

        3.4.1 final域
            在Java内存模型中，final域还有这特殊的语义。final域能确保初始化过程中的安全性
         从而可以不受限制地访问不可变对象，并在共享这些对象时无需同步
            "除非需要某个域是可变的，否则应将其声明为final域"是一个良好的编程习惯
        3.4.2 - 使用volatile类型来发布不可变对象 OneValueCache，VolatileCachedFactorizeer
            如何解决无法以原子方式来同时读取或更新两个相关的值(UnsafeCachingFactorizer)，同样，
         用volatile类型的变量来,保存这些值也不是线程安全的，这时候，可以考虑使用不可变对象，
         它会提供一种弱形式的原子性。

    3.5 安全发布 - StuffInfoPublic
        3.5.1 不正确的发布：正确的对象被创建 - Holder
            尽管在构造函数中设置的域似乎是第一次向这些域中写入的值，因此不会有“更旧的”值被视为失败值
         但Object的构造函数会在子类构造函数运行之前先将默认值写入所有的域。因此，某个域的默认值可能
         被视为失效值
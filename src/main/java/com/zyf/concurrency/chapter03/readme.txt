3.对象的共享
    同步除了可用于实现原子性和 确定“临界区（Critical Section）”，还有一个重要方面：内存可见性

    3.1 可见性 NoVisibility
        在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。在缺乏足够同步的多线程程序中，要想对内存操作的执行顺序进行判断，几乎无法得出正确的结论。重排序问题
        只要有数据在多个线程之间共享，就使用正确的同步。

    3.1.1 失效数据 MutableInteger，SynchronizedInteger
        问题点：get和set是复合操作，使用内置锁真的可以锁住value中的值吗？
            如果一个线程调用get只是锁住了get，而set和get并不是同一个锁
            解决（引自敖丙吊打面试官系列-https://mp.weixin.qq.com/s/WtAdXvaRuBZ-SXayIKu1mA）：
                synchronized，代表这个方法加锁，相当于不管哪一个线程（例如线程A），运行到这个方法时,
                都要检查有没有其它线程B（或者C、 D等）正在用这个方法(或者该类的其他同步方法)，
                有的话要等正在使用synchronized方法的线程B（或者C 、D）运行完这个方法后再运行此线程A，
                没有的话，锁定调用者，然后直接运行。

    3.1.3
        加锁的含义不仅仅局限于互斥行为，海报包括内存可见性。为了确保所有线程都能看到共享变量的最新值
      所有执行读操作或者写操作的线程都必须在同一个锁上同步

    3.1.4 - CountingSheep
        volatile变量
            是Java提供的稍弱的同步机制，用于确保变量的更新操作通知到其他线程。
            volatile变量不会被该变量的操作与其他内存操作一起重排序，volatile变量不会被缓存在
            寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值
            局限性：
                加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能
                确保可见性 - 可参见代码CountingSheep

    3.2 发布与溢出 Secrets，UnsafeStates，ThisEscape，SafeListener
        只有当构造函数返回时，this引用才应该从主线程中逸出，构造函数可以将引用保存到某个地方，
     只要其他瑕疵不会在构造函数完成之前使用他。 - 可参见代码SafeListener

    3.3 线程封闭
        3.3.2 栈封闭 - Animals
        3.3.3 ThreadLocal类
            这个类能使线程中的某个值与保存值的对象关联起来，类中的方法为每个使用该变量的线程
         都存有一份独立的副本，因此get总是返回由当前执行线程在调用set时设置的最新值，当线程终止
         后，值会作为垃圾回收
         缺点：
            降低代码的可重用性，并在类之间引入隐含的耦合性

    3.4 不变性 - ThreeStooges
        不可变对象对象一定是线程安全的
        当满足一下条件时，对象才是不可变的
            1、对象创建以后，其状态就不能修改
            2、对象的所有域都是final类型
            3、对象是正确创建的（在对象创建期间，this引用没有溢出）

        3.4.1 final域
            在Java内存模型中，final域还有这特殊的语义。final域能确保初始化过程中的安全性
         从而可以不受限制地访问不可变对象，并在共享这些对象时无需同步
            "除非需要某个域是可变的，否则应将其声明为final域"是一个良好的编程习惯
        3.4.2 - 使用volatile类型来发布不可变对象 OneValueCache，VolatileCachedFactorizeer
            如何解决无法以原子方式来同时读取或更新两个相关的值(UnsafeCachingFactorizer)，同样，
         用volatile类型的变量来,保存这些值也不是线程安全的，这时候，可以考虑使用不可变对象，
         它会提供一种弱形式的原子性。

    3.5 安全发布 - StuffInfoPublic
        3.5.1 不正确的发布：正确的对象被破坏 - Holder
            尽管在构造函数中设置的域似乎是第一次向这些域中写入的值，因此不会有“更旧的”值被视为失败值
         但Object的构造函数会在子类构造函数运行之前先将默认值写入所有的域。因此，某个域的默认值可能
         被视为失效值

        3.5.2 不可变对象与初始化安全性
            任何线程都可以在不需要额外同步的情况下安全地访问不可变对象，即使在发布这些对象时没有使用
         同步，此处需注意前提是final类型的域所指向的是不可变对象

        3.5.3 安全发布的常用模式
            1、在静态初始化函数中初始化一个对象引用
            2、将对象的引用保存到volatile类型的域或者AtomicReferance对象中
            3、将对象的引用保存到某个正确构造对象的final类型域中
            4、将对象的引用保存到一个由锁保护的域中

        3.5.4 事实不可变对象
            如果对象从技术上看是可变的，但其状态在发布后不会再改变，那么把这种对象
         称为事实不可变对象（Effectively Immutable Object）,如下代码
         public Map<String, Date> lastLogin =
             Collections.synchronizedMap(new HashMap<String, Date>());
            在没有额外同步的情况下，任何线程都可以安全地使用被安全发布的事实不可变对象

        3.5.5 可变对象
            对象的发布需求取决于他的可边性
            1、不可变对象可以通过任何机制来发布
            2、事实不可变对象必须通过安全方式来发布
            3、可变对象必须通过安全方式来发布，并且必须是线程安全的或者由某个锁保护起来

        3.5.6 安全的共享对象
            在并发程序中使用和共享对象时，可以使用一些实用的策略，包括：
                * 线程封闭
                    线程封闭的对象只能由一个线程拥有，对象呗封闭在该线程中，并且只能由这个线程修改
                * 只读共享
                    在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能
                 修改它。共享的只读对象包括不可变对象和事实不可变对象。
                 * 保护对象
                    被保护的对象只能通过持有特定的锁访问。保护对象包括封装在其他线程安全对象中的对象，
                 以及已发布的并且由某个特定锁保护的对象。
3.对象的共享
    同步除了可用于实现原子性和 确定“临界区（Critical Section）”，还有一个重要方面：内存可见性

    3.1 可见性 NoVisibility
        在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。在缺乏足够同步的多线程程序中，要想对内存操作的执行顺序进行判断，几乎无法得出正确的结论。重排序问题
        只要有数据在多个线程之间共享，就使用正确的同步。

    3.1.1 失效数据 MutableInteger，SynchronizedInteger
        问题点：get和set是复合操作，使用内置锁真的可以锁住value中的值吗？
            如果一个线程调用get只是锁住了get，而set和get并不是同一个锁

    3.1.3
        加锁的含义不仅仅局限于互斥行为，海报包括内存可见性。为了确保所有线程都能看到共享变量的最新值
      所有执行读操作或者写操作的线程都必须在同一个锁上同步

    3.1.4 - CountingSheep
        volatile变量
            是Java提供的稍弱的同步机制，用于确保变量的更新操作通知到其他线程。
            volatile变量不会被该变量的操作与其他内存操作一起重排序，volatile变量不会被缓存在
            寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值
            局限性：
                加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能
                确保可见性 - 可参见代码CountingSheep

